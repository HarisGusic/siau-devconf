#+TITLE: Konfigurator uređaja

Ovaj podmodul ima zadatak da omogući programeru da isprogramira novi pametni
uređaj. Naime, na osnovu odabranih konfiguracijskih parametara se generiše
programski kod koji je zatim potrebno uploadovati na mikrokontroler uređaja
korištenjem [[https://mbed.org][MBED]] platforme. Konfiguracijski parametri se zadaju u JSON formatu.

* NAPOMENA: JOŠ UVIJEK NIJE TESTIRANO NA WINDOWS-u - NEMOJTE POKRETATI NI ZA ŽIVU GLAVU!

* Opis principa

  Pošto se razvoj pametne kuće vrši u više iteracija te se paralelno vrši
  razvoj različitih komponenti koje trebaju da budu sinhronizovane, potrebno je
  uniformizirati pristupe. Na primjer tim koji kreira logiku i GUI treba da ima
  uniforman interfejs sa svim uređajima, tako da samo tim koji vrši
  konfiguraciju uređaja mora brinuti o finim detaljima uređaja. Iz tog razloga
  će svi uređaji biti predstavljeni preko JSON datoteka. Ostali timovi mogu ove
  datoteke pročitati kako bi mogli napraviti interfejs sa ovim uređajima.
  Također, ove datoteke će se iskoristiti za generisanje osnovnih C++ source
  predložaka, koje programer uređaja treba da implementira.

  Ovdje će ukratko biti opisan način korištenja ovog podmodula, a u nastavku će
  biti dokumentovane sve funkcije.

** U kratkim crtama

  *Osnovna komponenta konfiguratora uređaja je program* ~dev-conf~. Pokretanjem ovog
  programa kao
  #+begin_src shell
    dev-conf --setup .
  #+end_src
  se u trenutnom folderu generišu sljedeće datoteke:
  #+begin_src shell
    .
    ├── factory_device.json
    └── user_device.json
  #+end_src
  Ove datoteke sadrže predloške koje programer treba da popuni. Način
  popunjavanja će biti objašnjen u nastavku. Nakon što se to obavi, potrebno je
  pozvati program ponovo:
  #+begin_src shell
    dev-conf --input-dir . --output-dir output/
  #+end_src
  Na ovaj način će se u folderu ~output/~ generisati sljedeće datoteke:
  #+begin_src shell
    output/
    ├── factory_device.json
    ├── user_device.json
    ├── main.cpp
    ├── device.cpp
    └── device.h
  #+end_src
  TODO: eventualno generisati i mbed workspace korištenjem mbed-cli?

  Ove datoteke će biti popunjene osnovnim deklaracijama, koje programer treba da
  implementira. Također, programer ovdje može dodati još funkcionalnosti po
  volji.

  Nakon što se generiše sadržaj foldera ~output/~, programer može započeti
  programiranje mikrokontrolera korištenjem platforme /MBED/ u tom folderu.

* Reprezentacija uređaja

  Uređaji imaju dva seta parametara: tvorničke (~factory_device.json~) i
  korisničke (~user_device.json~). Tvornički parametri određuju hardverske parametre
  koji se ne mogu mijenjati, koje uređaji posjeduju kada izađu iz fabrike.
  Korisnički parametri su oni koji se mijenjaju prilikom svake ugradnje uređaja
  u pametnu kuću.

  Na osnovu podataka iz ~factory_device.json~ se može formirati baza podataka koja
  sadrži sve "prepoznate" uređaje, dok se na osnovu podataka iz ~user_device.json~
  može lokalna baza podataka koja sadrži sve uređaje koji se nalaze konkretnoj
  pametnoj kući.

** Tvornički parametri ~factory_device.json~
   #+begin_src json
     {
         "vendorId": "...",
         "deviceId": "...",
         "name": "Naziv C++ klase",
         "desc": "Ljudima čitljiv opis",
         "category": "...",
         "functions": [
             { // Funkcija 1
                 "name": "nazivMetode", "friendly": "Lijepi naziv",
                 "valueType": "tip_podatka", "valueRange": [ 0.0, 1.0 ], "unit": "%"
             },
             [ // Funkcija 1
                 { // Podfunkcija 1.1
                     "name": "podfunkcija_1", "friendly": "Lijepi naziv",
                     "valueType": "tip_podatka", "if": "uslov"
                 },
                 { // Podfunkcija 1.2
                     "name": "podfunkcija_2", "friendly": "Lijepi naziv",
                     "valueType": "tip_podatka", "if": "uslov"
                 }
             ]
         ],
         "values": [
             { // Prva vrijednost
                 "name": "nazivMetode", "friendly": "Lijepi naziv",
                 "valueType": "float"
             },
             { // Druga vrijednost
                 "name": "nazivMetode", "friendly": "Lijepi naziv",
                 "valueType": "EnumTip" [ "Stanje1", "Stanje2", ... ] 
             }
         ]
     }
   #+end_src
*** Identifikacijski atributi
**** ~vendorId~, ~deviceId~
     Ovi atributi predstavljaju identifikaciju uređaja i jedinstveni su za svaki
     uređaj istog modela, od istog proizvođača.
**** ~name~
     Predstavlja naziv C++ klase uređaja koja će se generisati da bi se uređaj
     mogao isprogramirati putem MBED platforme. Ovaj atribut je također
     jedinstven za svaki model uređaja.
**** ~desc~
     Predstavlja kratak tekstualni opis uređaja.
**** ~category~
     Određuje konceptualnu grupu kojoj pripada ovaj uređaj. Ovaj parametar se
     može iskoristiti za uljepšavanje reprezentacije uređaja na GUI. Na primjer, ako je
     njegova vrijednost ~Temperature~, onda će pored uređaja u GUI biti
     prikazana ikona termometra, itd.

*** Niz ~functions~
     Ovaj niz predstavlja niz funkcija koje uređaj može obavljati. Korisnik
     zadaje (pritiskom dugmeta, izborom iz liste ili sl.) komandu. Korisnik ovu
     komandu u GUI vidi pod imenom koje se zadaje atributom ~friendly~. U klasi
     ~Device~ će se generisati metoda sa nazivom ~name~ i koju programer treba da
     implementira za konkretni uređaj. Konceptualno, generisana metoda je
     /setter/.

     *Alternativno*, element ovog niza može biti ponovo niz. Taj niz predstavlja
      funkciju koja se sastoji od više podfunkcija. Ovo je korisno ako dvije
      funkcije konceptualno pripadaju istoj skupini (na primjer funkcije ~upali~ i
      ~ugasi~ za neku lampu).
**** ~valueType~
     Određuje tip podatka koji prima ova komanda. Ovaj podatak predstavlja
     payload odgovarajućeg topic-a. Može biti ~float~, ~int~, ~bool~, ~void~ ili
     naziv korisnički-definiranog enumeriranog tipa. Konkretne vrijednosti ovog
     enum-a se zadaju putem ~valueRange~. U headeru ~device.h~ će se generisati
     definicija ovog enum tipa, zajedno sa funkcijama koje vrše konverziju ovog
     tipa u string i obratno.

     Ako se ne navede atribut ~valueType~, onda će se uzeti da je on ~void~, što
     znači da ova funkcija ne zahtijeva nikakav ulazni podatak.
**** ~valueRange~
     U slučaju da je ~valueType~ neki brojni tip, ovaj atribut treba biti niz
     od dva elementa koji sadrži donju i gornju granicu vrijednosti. U slučaju
     da je ~valueType~ korisnički definirani enum tip, ovaj niz sadrži sve moguće
     vrijednosti ovog enum tipa.
**** ~unit~
     Mjerna jedinica koja se koristi isključivo za prikaz zadane vrijednosti za
     ovu funkciju u sklopu GUI. Ako se ne zada ovaj atribut, uzima se da je
     prazan string, tj. neće se koristiti mjerna jedinica. Naravno, ako je
     ~valueType~ jednak ~void~, onda ovaj atribut nema nikakvu ulogu.
     
*** Niz ~values~ 
    Sadrži /vrijednosti/ koje se mogu zatražiti od uređaja. Ovo su najčešće
    nekakva mjerenja, ili trenutno stanje uređaja. Atribut ~name~ svake
    vrijednosti sadrži jedinstveni identifikator, koji ujedno predstavlja i ime
    metode u C++ klasi ~Device~. Konceptualno, ova metoda je /getter/. Atribut
    ~friendly~ je string koji određuje pod kojim nazivom će se korisniku
    prikazati /vrijednost/ u sklopu GUI. Atribut ~valueType~ može biti jedan od
    tipova ~float~, ~int~, ~bool~ ili naziv korisnički definiranog
    enumeriranog tipa. U posljednjem slučaju se zadaje dodatni atribut
    ~valueRange~ koji sadrži moguće vrijednosti ovog enum tipa. Konačno, atribut
    ~unit~ predstavlja mjernu jedinicu koja se koristi prilikom prikaza
    vrijednosti u GUI.
** Korisnički parametri ~user_device.json~
   #+begin_src json
     {
         "name": "jedinstven_naziv_u_konkretnoj_pametnoj_kući",
         "databaseId": "...",
         "serialNo": "...",
         "location": "soba, sprat, ili sl.",
         "ip": "...",
         "subnet_mask": "...",
         "default_gateway": "..."
     }
   #+end_src
   Ovi parametri se zadaju tek kada se uređaj konfiguriše za konkretan objekat.
   Njihovo značenje je jasno samo po sebi pa se neće dodatno objašnjavati.

** Anatomija topic-a

   Svaki topic treba da bude formata:

   ~lokacija/uređaj/poruka~

   Pri tome ~lokacija~ uređaja može predstavljati na primjer naziv sobe, polje
   ~uređaj~ je jedinstvena identifikacija uređaja (vjerovatno serijski broj -
   TODO). Polje ~poruka~ predstavlja naziv poruke i *identično* je nazivu funkcije
   uređaja koju je potrebno izvršiti, ili vrijednosti koja se čita sa uređaja.
   Na primjer ako neki uređaj ima serijski broj ~001-2340~ i nalazi se u sobi
   ~dnevni_boravak~, te potrebno je izvršiti funkciju:

   #+begin_src json
     { "name": "setTemp", "friendly": "Set Temperature", "value": 25.0 }
   #+end_src

   onda će odgovarajući topic biti:

   ~dnevni_boravak/001-2340/setTemp~

   pri čemu će /payload/ sadržavati floatan broj koji predstavlja zadanu vrijednost
   temperature.

** Konkretan primjer

   Ovdje će biti razmotren jedan jednostavan konkretan primjer: pametna
   sijalica. Ova sijalica se može uključivati/isključivati preko WiFi-a, te se
   može zadavati jačina svjetlosti.

*** Tvornička konfiguracija

    #+begin_src json
      {
          "name": "SmartLight",
          "vendorId": "ETF",
          "deviceId": "LX34-U6M",
          "category": "Light",
          "values": [
              {
                  "name": "getBrightness", "friendly": "Brightness",
                  "valueType": "float", "unit": "%"
              },
              {
                  "name": "getState", "friendly": "State",
                  "valueType": "StateOnOff", "valueRange": [ "On", "Off" ]
              }
          ],
          "functions": [
              [
                  { "name": "turnOn", "friendly": "Turn On", "if": "getState=Off" },
                  { "name": "turnOff", "friendly": "Turn Off", "if": "getState=On" }
              ],
              {
                  "name": "setBrightness", "friendly": "Set Brightness",
                  "valueType": "float", "valueRange": [ 0.0, 100.0 ], "unit": "%"
              }
          ]
      }
    #+end_src

*** Korisnička konfiguracija
    
    #+begin_src json
      {
          "name": "Pametna sijalica 1",
          "databaseId": "123",
          "serialNo": "LG-0001",
          "location": "hodnik",
          "ip": "192.168.1.100",
          "subnet_mask": "255.255.255.0",
          "default_gateway": "192.168.1.1"
      }
    #+end_src

    Identifikacijski parametri su proizvoljno odabrani.

    Kada korisnik odabere ovaj uređaj na GUI, uz njega će se prikazati ikona koja
    se vezuje za uređaje iz kategorije "Light". Također, biće prikazane sljedeće
    vrijednosti (definirane u nizu ~values~):

    - Jačina svjetlosti (Brightness)

      Vrijednost trenutne jačine svjetlosti će se čitati sa uređaja preko
      topic-a ~hodnik/LG-0001/getBrightness~. Ova vrijednost će se prikazivati
      korisniku sa mjernom jedinicom "%".

      Klasa ~Device~ u generisanoj datoteci ~device.h~ će sadržavati metodu
      ~getBrightness~, koja vraća vrijednost tipa ~float~, i koju programer treba da
      implementira.

    - Stanje uređaja (State)

      Predstavlja trenutno stanje uređaja (On - svjetlo je upaljeno, Off -
      svjetlo je ugašeno). Stanje se čita sa uređaja preko topic-a
      ~hodnik/LG-0001/getState~, pri čemu /payload/ sadrži string "On" ili "Off"
      zavisno od stanja uređaja. 

      Klasa ~Device~ će sadržavati definiciju enumeriranog tipa ~StateOnOff~ sa
      vrijednostima ~Off~ i ~On~, funkciju za konverziju ovog tipa u string i
      obratno, kao i metodu ~getState~, koja vraća vrijednost tipa ~StateOnOff~ i
      koju programer treba da implementira.

    Korisnik može pomoću grafičkih widget-a zadavati vrijednosti koje se šalju
    uređaju, odnosno funkcije koje on treba da izvrši:

    - Funkcije ~turnOn~ i ~turnOff~

      Ovo su dvije podfunkcije koje se nalaze u sastavu jedne funkcije. Dakle,
      njihova nadfunkcija predstavlja niz podfunkcija. To je urađeno tako da bi
      se na GUI funkcionalnost paljenja/gašenja mogla upravljati preko jednog
      widgeta. Taj widget može biti na primjer /ToggleButton/.

      Za obje funkcije će biti generisane istoimene metode u sklopu klase ~Device~
      u datoteci ~device.h~, bez parametara.
      
      Također, funkcija ~turnOn~ sadrži i atribut ~if~ koji određuje uslov pod kojim
      je aktivna ova funkcija za razliku od funkcije ~turnOff~. Također i funkcija
      ~turnOff~ sadrži uslov pod kojim je ona aktivna za razliku od funkcije
      ~turnOn~. Ovi uslovi respektivno glase: ~getState=Off~ i ~getState=On~. Dakle,
      funkcija ~turnOn~ će se moći pozvati kada je stanje uređaja "Off", a
      funkcija ~turnOff~ kada je stanje uređaja "On". Ovaj atribut se /ne koristi
      prilikom generisanja datoteke/ ~device.h~.

    - Funkcija ~setBrightness~

      Služi za podešavanje jačine svjetlosti. Korisniku je ova opcija na GUI
      prikazana kao "Set Brightness". Prima vrijednost tipa ~float~ iz opsega od
      0.0 do 100.0, pri čemu je na GUI uz to prikazana i mjerna jedinica "%". U
      klasi ~Device~ iz ~device.h~ se generiše istoimena funkcija koja prima
      vrijednost tipa ~float~. Zadana vrijednost se šalje uređaju putem topic-a
      ~hodnik/LG-0001/setBrightness~.

* BUILD
  Da bi se izgradio program ~dev-conf~, potrebno je instalirati sljedeće programe.

** Potrebni programi i biblioteke
   - [[https://github.com/open-source-parsers/jsoncpp][jsoncpp]]
   - CMake min. ver. 3.10
   - make
   - python3, docutils (samo za generisanje manpage-a)

   Trebalo bi da se svi ovi alati mogu instalirati korištenjem vašeg omiljenog
   package manager-a.

** Izgradnja
   Potrebno je pokrenuti komandu:
   #+begin_src shell
     make
   #+end_src
   Ovo će kreirati program ~dev-conf~ i manpage, koji će biti smješteni u folderu
   ~_build/~. Alternativno, moguće je pozvati:
   #+begin_src shell
     make app
   #+end_src
   odnosno
   #+begin_src shell
     make man
   #+end_src
   da bi se ove komponente izgradile pojedinačno.

   *NAPOMENA:* Ovako generisan program ~dev-conf~ se smije pozivati samo iz root
   foldera projekta, u suprotnom neće raditi korektno.
   
   Ako je potrebno program kompajlirati direktno iz ~CMakeLists.txt~, ova datoteka
   se nalazi u folderu ~src/.~
   
** Instalacija

   Program ~dev-conf~ se može instalirati korištenjem komande:
   #+begin_src shell
     make install INSTALL_DIR=<DIR>
   #+end_src
   *NAPOMENA:* ~<DIR>~ *mora biti apsolutna putanja. Ovo je od krucijalnog značaja!*
    
   Ako se komanda pozove samo kao ~make install~, tj. ako se ne zada varijabla
   ~INSTALL_DIR~, program će biti instaliran u folderu ~/usr/local~. U tom slučaju
   je potreban ~sudo~ pristup.

* Komanda ~dev-conf~
  
  Ova komanda će se koristiti za generisanje /source datoteka/ na osnovu /JSON
  datoteka/ i predložaka /C++ datoteka/. Dokumentacija (source) ove komande se
  nalazi u datoteci ~docs/man.rst~. Ova dokumentacija se može build-at putem:
  #+begin_src shell
    make man
  #+end_src
  pri čemu će se generisati *Linux Manpage* ~_build/dev-conf.1.gz~. Ovaj manpage se
  može otvoriti korištenjem komande (na Linux-u):
  #+begin_src shell
    man -l _build/dev-conf.1.gz
  #+end_src
  Međutim, source ovog manpage-a je već itekako čitljiv, pogotovo na
  GitHub/GitLab-u.

* Primjer korištenja

  Najprije je potrebno instalirati program ~dev-conf~ negdje. Za ovo pogledati
  poglavlje *BUILD*, te potpoglavlje instalacija. Poželjno je instalirati program
  na neku lokaciju koja je u ~PATH~. Ovo nije neophodno, ali pojednostavljuje
  stvar.

  Nakon što je sve spremno, potrebno je izvršiti sljedeće komande.

  #+begin_src shell
    mkdir input_dir/ && dev-conf --setup input_dir/
  #+end_src
  
  U folderu ~input_dir/~ će biti generisani template JSON datoteke, koje je
  potrebno popuniti sa konkretnim konfiguracijskim parametrima uređaja. *Trenutno
  je implementiran samo dio funkcionalnosti i to za fajl* ~factory_device.json~. I
  za taj fajl, implementirano je samo parsiranje atributa ~name~, ~vendorId~ i
  ~deviceId~. Pri tome, atribut ~name~ mora biti validno ime C++ klase. Ostale
  atribute ne vrijedi mijenjati jer nemaju efekta (još uvijek).

  Kada završite editovanje ove datoteke, pokrenite sljedeću komandu:
  #+begin_src shell
    mkdir output_dir/ && dev-conf --input-dir input_dir/ --output-dir output_dir/
  #+end_src

  Et voilà!
  Sada se u folderu ~output_dir/~ nalaze potrebni source fajlovi i možete započeti
  programiranje MBED uređaja! (TODO naravno, trenutno baš i ne možete jer nije
  sve implementirano).

  Da biste se uvjerili da je sve ispravno, otvorite datoteku ~output_dir/device.h~
  i provjerite da li je naziv klase isti kao atribut ~name~ u fajlu
  ~factory_device.json~. Također, povratne vrijednosti iz generisanih metoda u toj
  klasi bi trebale odgovarati atributima koje ste zadali u datoteci
  ~input_dir/factory_device.json~.
  
* Primjer TODO ovo ne čitati jer je nedovršeno!!!!

  *Preporučuje se detaljno proći kroz ovaj primjer, kako bi se razumio tok rada.*

  Neka je potrebno isprogramirati novi uređaj: pametnu utičnicu. Ovaj uređaj je
  pametan u smislu da se može omogućiti/onemogućiti putem WiFi-a, te prati
  podatke o vrijednostima i potrošnji koje korisnik može da vidi putem
  aplikacije.

  Najprije je potrebno kreirati fajl ~factory_device.json~, čiji je sadržaj
  prikazan u nastavku.
  
  #+begin_src json
    {
        "name": "SmartPlug",
        "vendorId": "ETF",
        "deviceId": "SP-51-3010",
        "category": "Plug",
        "desc": "A smart plug",

        "functions": [
            [
                { "name": "enable", "friendly": "Enable" },
                { "name": "disable", "friendly": "Disable" }
            ]
        ],

        "values": [
            { "name": "powerUsage", "friendly": "Power Usage", "value": 0.0 },
            { "name": "status", "friendly": "Status",
                "value": [ "Enabled", "Disabled", "Fault" ] }
        ]
    }
  #+end_src

  Zatim je na osnovu ovog fajla, te predloška ~device.h.in~ potrebno generisati
  /header/ datoteku ~device.h~. Ovo se radi korištenjem sljedeće komande:

  #+begin_src sh
    dev-conf --json SmartPlug.json --in device.h.in --main-in main.cpp.in \
             --out gen/device.h --main-out gen/main.cpp
  #+end_src

se treba odrediti ~naziv~ uređaja koji predstavlja *naziv C++ klase* koja
  će se generisati za taj uređaj. Zatim je potrebno odrediti /tvorničke podatke/
  za taj uređaj: ~vendorId~ i ~deviceId~. Parametar 
  
